<!DOCTYPE html>
<html>
<head>
    <meta charset=utf-8 />
    <title>  Kohl Kinning </title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/pygment_trac.css">
    <link rel="stylesheet" href="/css/jquery.bxslider.css" />
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
    <script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.9.1/jquery-ui.min.js"></script>
    <script src="/js/jquery.bxslider.min.js"></script>

    <script src="https://use.typekit.net/nrf6yfy.js"></script>
    <script>try{Typekit.load({ async: true });}catch(e){}</script>
    <script src="/js/libs/three.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/p5.js/0.5.2/p5.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/p5.js/0.5.2/addons/p5.dom.js" type="text/javascript"></script>
    <script src="/js/libs/quicksettings.min.js"></script>
</head>

<body>
	<div class="wrapper">
		<header>
		<nav role="navigation">
			<ul>
				<li><a href="/about/"> About </a></li>
				<li><a href="/portfolio/"> Projects </a></li>
				<li><a href="/blog/"> Blog </a></li>
				<li><a href="/contact/"> Contact </a></li>
			</ul>
		</nav>
		</header>
		
		<!-- Animation Canvas -->
		<div id="backgroundCanvas">
			<!-- Wrapper -->
			<div id="wrapper">
			

	
		 	<div class="wrapper">
        <section>
        <h2 class="content">Assignment 5</h2>

          <p class="post-meta">
                01 Sep 2017
          </p>

        <p><strong>de novo Transcriptome Assembly</strong>
The objective of this assignment is to complete the tasks necessary for assembling and evaluating a transcriptome. The transcriptome of interest is the male brood pouch transcriptome of the Gulf pipefish, Syngnathus scovelli. The RNA-seq data are paired-end, 100 nt reads sequenced from Illumina TruSeq libraries on a HiSeq2000.</p>

<h3 id="block-1-cleaning-filtering-and-digital-normalization-of-the-data">Block 1: Cleaning, Filtering, and Digital Normalization of the Data</h3>

<h4 id="1-use-the-process_shortreads-program-which-is-part-of-the-stacks-package-to-clean-the-set-of-paired-end-reads">1| Use the process_shortreads program, which is part of the Stacks package, to clean the set of paired-end reads</h4>

<pre><code class="language-bash">$ process_shortreads -1 SscoPE_R1.fastq -2 SscoPE_R2.fastq -i fastq -o Cleaned/ -c -q --adapter_mm 2 --adapter_1 AGATCGGAAGAGCACACGTCTGAACTCCAGTCAC --adapter_2 AGATCGGAAGAGCGTCGTGTAGGGAAAGAGTGT
</code></pre>

<h4 id="2-using-unix-commands-summarize-the-distributions-of-read-lengths-one-for-r1s-one-for-r2s-for-the-trimmed-data-plot-these-distributions-in-r">2| Using UNIX commands summarize the distributions of read lengths (one for R1s, one for R2s) for the trimmed data. Plot these distributions in R</h4>

<pre><code class="language-bash">$ awk 'NR % 4 == 2' SscoPEclean_R1.fq | awk '{print length}' |sort | uniq -c &gt; R1_lengths.txt
$ awk 'NR % 4 == 2' SscoPEclean_R2.fq | awk '{print length}' |sort | uniq -c &gt; R2_lengths.txt
</code></pre>

<pre><code class="language-r">r1 = read.table("/Users/kohl/Documents/GradSchool/semester1/TopicsInGenomicAnalysis/Assignments/TopicsInGenomicAnalysis/assignment5/R1_lengths.txt")

r2 = read.table("/Users/kohl/Documents/GradSchool/semester1/TopicsInGenomicAnalysis/Assignments/TopicsInGenomicAnalysis/assignment5/R2_lengths.txt")

colnames(r1)[1:2] = c("counts", "lengths")
colnames(r2)[1:2] = c("counts", "lengths")
</code></pre>

<pre><code class="language-r">plot(r1$counts~r1$lengths, log = "y", col = "magenta4", pch = 3, xlab = "read lengths", ylab = "counts", main = "Trimmed Data Distributions")
points(r2$counts~r2$lengths, col = "green4", pch = 5)
</code></pre>

<p><img src="assignment5_files/figure-markdown_github/unnamed-chunk-2-1.png" alt="" /></p>

<h4 id="3-filter-the-cleaned-data-for-rare-k-mers-using-kmer_filter">3| Filter the cleaned data for rare k-mers using <code>kmer_filter</code></h4>

<pre><code class="language-bash">ml purge
ml slurm
ml easybuild  icc/2017.1-GCC-6.3-2.27  impi/2017.1
ml Stacks/1.46

kmer_filter -1 ../SscoPEclean_R1.fq -2 ../SscoPEclean_R2.fq -i fastq -o Filtered/ --rare
</code></pre>

<h4 id="4-run-kmer_filter-again-this-time-to-normalize-the-cleaned-filtered-data-to-2-different-coverages">4| Run <code>kmer_filter</code> again, this time to normalize the cleaned, filtered data to 2 different coverages</h4>

<p><em>What’s happening to the data?</em>
The cleaned and filtered data is being further culled. Only those reads with 40x coverage or 20x coverage are kept. The result is smaller files with less (higher quality) data.</p>

<p>With 40x coverage.</p>

<pre><code class="language-bash">ml purge
ml slurm
ml easybuild  icc/2017.1.132-GCC-6.3.0-2.27  impi/2017.1.132
ml Stacks/1.46

kmer_filter -1 SscoPEcleanfil_R1.fq -2 SscoPEcleanfil_R2.fq -i fastq -o Normed/ --rare --normalize 40
</code></pre>

<p>With 20x coverage.</p>

<pre><code class="language-bash">ml purge
ml slurm
ml easybuild  icc/2017.1.132-GCC-6.3.0-2.27  impi/2017.1.132
ml Stacks/1.46

kmer_filter -1 SscoPEcleanfil_R1.fq -2 SscoPEcleanfil_R2.fq -i fastq -o Normed/ --rare --normalize 20
</code></pre>

<h4 id="6-now-run-kmer_filter-3-times---on-the-cleaned-set-the-cleanedfiltered-set-and-the-cleanedfiltered20x-normalized-set">6| Now run kmer_filter 3 times - on the cleaned set, the cleaned/filtered set, and the cleaned/filtered/20X normalized set</h4>

<pre><code class="language-bash">ml purge
ml slurm
ml easybuild  icc/2017.1.132-GCC-6.3.0-2.27  impi/2017.1.132
ml Stacks/1.46

kmer_filter -1 Cleaned/SscoPEclean_R1.fq -2 Cleaned/SscoPEclean_R2.fq -i fastq -o Dists/ --k_dist

kmer_filter -1 Cleaned/Filtered/SscoPEcleanfil_R1.fq -2 Cleaned/Filtered/SscoPEcleanfil_R2.fq  -i fastq -o Dists/ --k_dist

kmer_filter -1 Cleaned/Filtered/Normed/SscoPEcleanfil_R1.fil.norm.fq  -2 Cleaned/Filtered/Normed/SscoPEcleanfil_R2.fil.norm.fq -i fastq -o Dists/ --k_dist
</code></pre>

<p>Plot the distributions.</p>

<pre><code class="language-r">cleaned = read.table("/Users/kohl/Documents/GradSchool/semester1/TopicsInGenomicAnalysis/Assignments/TopicsInGenomicAnalysis/assignment5//Dists/dist_1.tsv", header = TRUE)
filtered = read.table("/Users/kohl/Documents/GradSchool/semester1/TopicsInGenomicAnalysis/Assignments/TopicsInGenomicAnalysis/assignment5/Dists/dist_2.tsv", header = TRUE)
normed = read.table("/Users/kohl/Documents/GradSchool/semester1/TopicsInGenomicAnalysis/Assignments/TopicsInGenomicAnalysis/assignment5/Dists/dist_3.tsv", header = TRUE)


plot(log(cleaned$Count)~log(cleaned$KmerFrequency),
      main="Cleaned, filtered, and normalized k-mer frequencies",
     type="n",
     xaxt="n",
     yaxt="n",
     xlab="k-mer frequency",
     ylab="counts")
points(log(cleaned$Count)~log(cleaned$KmerFrequency), pch = ".")
points(log(filtered$Count)~log(filtered$KmerFrequency), col = "green4",pch = ".")
points(log(normed$Count)~log(normed$KmerFrequency), col = "magenta4", pch = ".")

legend(9, 15, legend = c("cleaned", "filtered", "normalized"), col = c("green4", "black", "magenta4"), lty = 1)
</code></pre>

<p><img src="assignment5_files/figure-markdown_github/unnamed-chunk-3-1.png" alt="" /> ### Block 2: Trinity Assembly</p>

<h4 id="1-files-produced-after-running-trinity">1| Files produced after running Trinity</h4>

<p>The files produced with “rare” in the name are from a Trinity assembly based on the “cleaned, rare-kmer-filtered only” Gulf pipefish reads from Block 1. The files with “40Xnorm” are output from a Trinity run based on the cleaned, rare-kmer-filtered, 40X-normalized reads.</p>

<pre><code class="language-bash">$ Trinity.pl --seqType fq --JM 50G --left $work/SscoPEcleanfil_R1.fq \--right $work/SscoPEcleanfil_R2.fq --output $work/assembly --CPU 10 \--min_contig_length 300 --min_kmer_cov 3 --group_pairs_distance 800
</code></pre>

<h3 id="block-3-evaluation-of-trinity-assemblies">Block 3: Evaluation of Trinity Assemblies</h3>

<h4 id="1-retrieve-the-trinity-files">1| Retrieve the Trinity files</h4>

<pre><code class="language-bash">/home/csmall/Bi623/trinity/tri_rare.fasta
/home/csmall/Bi623/trinity/tri_rare.timing 
/home/csmall/Bi623/trinity/tri_40Xnorm.fasta 
/home/csmall/Bi623/trinity/tri_40Xnorm.timing
</code></pre>

<h4 id="2-files-produced-by-trinity">2| Files produced by Trinity</h4>

<p>The files with “rare” in the name are from a Trinity assembly based on the “cleaned, rare-kmer-filtered only” Gulf pipefish reads from Block 1. The files with “40Xnorm” are output from a Trinity run based on the cleaned, rare-kmer-filtered, 40X-normalized reads. Look at the information in the .timing files.</p>

<p><em>Do any differences between the rare and 40Xnorm assemblies stand out?</em></p>

<p>The 40X assembly had 81,798,333 kmers, whereas the rare kmer assembly had 86,151,364. The latter had 4.35303110^{6} more kmers than the 40X assembly. This is a huge difference!</p>

<h4 id="4-assembly-stats">4| Assembly stats</h4>

<p>Using information in the two assembly files, calculate the number of transcripts, the maximum transcript length, the minimum transcript length, the mean transcript length, and the median transcript length. Plot the contig length distributions for each assembly.</p>

<pre><code class="language-bash">$ sed -e 's/\(^&gt;.*$\)/#\1#/' tri_rare.fasta | tr -d "\r" | tr -d "\n" | sed -e 's/$/#/' | tr "#" "\n" | sed -e '/^$/d' | grep -Po [A-Z].+ | sed 's/[^"]//g' | awk '{ print length }' &gt; seq_tri_rare.fasta

$ sed -e 's/\(^&gt;.*$\)/#\1#/' tri_40Xnorm.fasta | tr -d "\r" | tr -d "\n" | sed -e 's/$/#/' | tr "#" "\n" | sed -e '/^$/d' | grep -Po [A-Z].+ | awk '{ print length }' &gt; seq_tri_40Xnorm.fasta
</code></pre>

<pre><code class="language-r">rare = read.table("/Users/kohl/Documents/GradSchool/semester1/TopicsInGenomicAnalysis/Assignments/TopicsInGenomicAnalysis/assignment5/seq_tri_rare.fasta")
colnames(rare) = "length"

forty = read.table("/Users/kohl/Documents/GradSchool/semester1/TopicsInGenomicAnalysis/Assignments/TopicsInGenomicAnalysis/assignment5/seq_tri_40Xnorm.fasta")
colnames(forty) = "length"
</code></pre>

<pre><code class="language-r">summary(rare)
</code></pre>

<pre><code>##      length     
##  Min.   :  301  
##  1st Qu.:  856  
##  Median : 1960  
##  Mean   : 2483  
##  3rd Qu.: 3440  
##  Max.   :18857
</code></pre>

<pre><code class="language-r">summary(forty)
</code></pre>

<pre><code>##      length     
##  Min.   :  301  
##  1st Qu.: 1041  
##  Median : 2139  
##  Mean   : 2600  
##  3rd Qu.: 3546  
##  Max.   :22465
</code></pre>

<pre><code class="language-r">par(mfrow=c(2,2))

hist(rare$length, ylim = c(0, 35000), xlim = c(0, 15000), xlab = "transcript length", main = "Rare kmer Lengths")
hist(forty$length, ylim = c(0, 35000), xlim = c(0, 15000), xlab = "transcript length", main = "40X mer Coverage Lengths")

boxplot(rare$length, ylim = c(0, 25000))
boxplot(forty$length, ylim = c(0, 25000))
</code></pre>

<p><img src="assignment5_files/figure-markdown_github/unnamed-chunk-7-1.png" alt="" /></p>

<h4 id="5-assembly-quality">5| Assembly quality</h4>

<p><em>Based on your assembly statistics and what you know about transcripts, comment on whether there is a clear difference in quality between the two Trinity assemblies.</em></p>

<p>When considering assembly statistics, the 40X assembly wins out. It has a higher median, mean, and maximum length compare to the rare kmer assembly.</p>

<p><em>Comment on differences in the total number of transcripts and transcript groups (“loci”) for the two assemblies. Basically, how many of the transcripts belong to groups that represent a bundle of similar sequences? What might transcripts within a bundle represent?</em></p>

<p>I find 9757 unique transcripts in the 40X assembly and 9442 unique transcripts in the rare kmer assembly. The 40X assembly has more unique transcripts than the rare kmer assembly, but the difference is not very large. The latter has 0.9677155 of the uniquue transcripts that the former does.</p>

<p>I find 18378 unique clusters in the 40X assembly and 17106 unique clusters for the rare kmer assembly. Again, the 40X assembly has more unique clusters but the difference is not very large. The latter has 0.9307868 of the unique clusters that the former does.</p>

<p>The software assembles bundles of fragment alignments to reduce running time and memory use. Each bundle typically contains the fragments from no more than a few genes.</p>

<h4 id="6-build-a-stickleback-database-blast-pipefish-transcripts-against-stickleback-protein-sequences">6| Build a stickleback database, BLAST pipefish transcripts against stickleback protein sequences</h4>

<pre><code class="language-bash">$ makeblastdb -in Gasterosteus_aculeatus.BROADS1.pep.all.fa -dbtype prot -out stickle 
</code></pre>

<pre><code class="language-bash">ml BLAST+/2.2.27

blastx -db stickle -query ../tri_40Xnorm.fasta -evalue 1e-5 -max_target_seqs 1 -outfmt 6 -out 40Xnorm_stickle_blast
</code></pre>

<pre><code class="language-bash">ml BLAST+/2.2.27

blastx -db stickle -query ../tri_rare.fasta -evalue 1e-5 -max_target_seqs 1 -outfmt 6 -out rare_stickle_blast
</code></pre>

<h4 id="8-blast-results">8| BLAST results</h4>

<p>For each top stickleback BLAST hit you identify, look up the human readable gene name (AKA external gene ID) from the stickleback file. Produce a table of the top BLAST hits you identified for each pipefish transcript, including the trinity transcript ID, stickleback blast hit e-value, stickleback blast hit protein ID, and stickleback hit external gene ID.</p>

<p><em>Are there more unique stickleback hits for one assembly vs. the other?</em></p>

<p>The assembly filtering for rare kmers only had significantly more unique hits than the one normalized to 40X coverage. This is expected as 40X kmer coverage is a stringent parameter.</p>

<h4 id="9-cegs">9| CEGs</h4>

<p>Look at the file <code>/home/csmall/Bi623/trinity/rare_ceg.completeness_report</code>.</p>

<p><em>What does this file tell you about transcriptome completeness for CEGs, and redundancy within our rare-kmer-filtered assembly?</em></p>

<p>Our CEG completeness report is excellent. We see that 245 of 248 of the ultra-conserved eukaryotic genes were recoverd. We also see that on average there are 3 orthologs per CEG found in the genome. We are missing a couple of CEGS that have completelely matched, but two of the three missing are found as partial matches. I’ve read that it’s rare to see all core genes present, even when you allow for partial matches. A 98.79% completeness is a good result.</p>


	
    </section>

</div>
 
		 	
		 	
		 
			<!-- Wrapper -->
 			</div>
		<!-- Animation Canvas -->
		</div>

	
		<footer>
				<p>
					<small>©2017 Kohl Kinning</small><br />
					<small>Made with <a href="http://jekyllrb.com/">Jekyll</a> &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small>
				</p>
		</footer>
	</div>
		
	<body>    
    	<script src="/js/scale.fix.js"></script>
  	</body>

</body>
</html>
